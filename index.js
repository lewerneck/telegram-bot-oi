const express = require('express'); // ou o framework que voc√™ est√° usando
const app = express();
const PORT = process.env.PORT || 10000; // Usa a porta do ambiente ou 10000 como padr√£o


const { Telegraf, Markup } = require('telegraf');
const axios = require('axios');
const bot = new Telegraf('7886636657:AAFq1ogAzjhFpfiJMue-Lwp9lsm_3XZqpjM');

// Inicia o servidor
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

// Ajuste os timeouts conforme necess√°rio
server.keepAliveTimeout = 120000; // 120 segundos
server.headersTimeout = 120000; // 120 segundos

// URL base da API
const API_BASE_URL = 'https://api.pushinpay.com.br/api';

// Define a chave da API do Pushin Pay
const PUSHIN_PAY_API_KEY = '1720|hZ42SlgkeM27SP6J1oJWR5I3hgmqKg988TtQtJsE5f93fe73';

// URL do webhook do Google Apps Script
const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbwrLb9oaQIKfLYXmamgIfWcvdbyZzFXNl-Kd_MfHIsPb8reF6XEx-13XDHNhJnJsHx_/exec';

// ID do administrador (substitua pelo ID do seu administrador)
const ADMIN_ID = '5308694170';

// Vari√°vel para armazenar o nome do bot
let botName = '';

// Armazenar IDs de mensagens
	const messageIds = {};
	const verificationMessageIds = {};
	const generatingPaymentMessageIds = {};
	const generatingMessageIds = {};
	const successPaymentMessageIds = {};
	const qrCodeMessageIds = {};
	const verificarNovamenteMessageIds = {};
	const jaPagouMessageIds = {};
	const vique1MessageIds = {};
	const vique2MessageIds = {};
	const desc1MessageIds = {};
	const desc2MessageIds = {};
	const generatingCheckoutMessageIds = {};
	const paymentChoiceMessageIds = {};
	

// Objeto para armazenar os valores dos pacotes
const precosPacotes = {
    Morango: 1990,  
    Pessego: 3700,  
    Cereja: 5700,   
};

// Fun√ß√£o para obter o nome do bot
async function obterNomeBot() {
    const me = await bot.telegram.getMe();
    botName = me.first_name; 
}

// Iniciar o bot e chamar a fun√ß√£o de boas-vindas
bot.start(async (ctx) => {
 await iniciarFluxoDeConteudo(ctx);
 });

// Fun√ß√£o para i niciar o fluxo de conte√∫do
async function iniciarFluxoDeConteudo(ctx) {
	
    // Obtendo o primeiro nome do usu√°rio
    const primeiroNome = ctx.from.first_name;

    // Enviando mensagem inicial
    await ctx.reply(`Oiie ${primeiroNome} ‚ù§Ô∏è Voc√™ finalmente encontrou meu chat secreto üòà`);

    // MENSAGEM 1 - PACOTE CEREJA
    const videoUrlCereja = 'https://video.gumlet.io/66180b4d8ec2efeb9164568c/671bc33038a902e47566e3d1/download.mp4';
    const captionCereja = `Nesse dia eu tava com muita vontade de transar, uma vontade de ficar de quatro pra qualquer homem que me olhasse\\.\\.\\. Ent√£o fui pedir a√ß√∫car pro meu vizinho e ele me deu pau \n\n` +
                          `***Pacote Cereja üçí*** \n` +
						  `25 V√≠deos e 20 Fotos \n\n` +
						  `S√£o v√°rios v√≠deos chupando, gozando de quatro, sozinha, com clientes\\.\\.\\. \n` +
                          `Quer ver me ver de todos os jeitinho e me macetando gostoso\\? Hahaha`;

    const inlineKeyboardCereja = Markup.inlineKeyboard([
        [Markup.button.callback('Comprar por R$ 57', 'Cereja')]
    ]);

    // Delay de 5 segundos antes de enviar MENSAGEM 1
    setTimeout(() => {
        ctx.replyWithVideo(videoUrlCereja, { caption: captionCereja, parse_mode: 'MarkdownV2', reply_markup: inlineKeyboardCereja.reply_markup });
    }, 5000); // 5 segundos

    // MENSAGEM 2 - PACOTE P√äSSEGO
    const videoUrlPessego = 'https://video.gumlet.io/66180b4d8ec2efeb9164568c/671bc33062fc4203b2e25318/download.mp4';
    const captionPessego = `***Pacote P√™ssego üçë*** \n`+
						   `20 V√≠deos e 15 Fotos \n\n` +
						   `Nesse pack est√£o os videozinhos chupando meu tio e brincando com a minha bucetinha at√© ela ficar toda melada do meu gozo, al√©m dos v√≠deos socando bem forte no meu cuzinho \n\n` +
                           `Quer me ver toda molhadinha\\? üôà`;

    const inlineKeyboardPessego = Markup.inlineKeyboard([
        [Markup.button.callback('Comprar por R$ 37', 'Pessego')]
    ]);

    // Delay de 10 segundos antes de enviar MENSAGEM 2 (total de 15 segundos ap√≥s a primeira)
    setTimeout(() => {
        ctx.replyWithVideo(videoUrlPessego, { caption: captionPessego, parse_mode: 'MarkdownV2', reply_markup: inlineKeyboardPessego.reply_markup });
    }, 7000); // 15 segundos (5s + 10s)

    // MENSAGEM 3 - PACOTE MORANGO
    const videoUrlMorango = 'https://video.gumlet.io/66180b4d8ec2efeb9164568c/671bc33038a902e47566e3d3/download.mp4';
    const captionMorango = `***Pacote Morango üçì*** \n` + 
						   `13 V√≠deos e 10 Fotos \n\n` +
						   `Nesse pack voc√™ vai encontrar meus melhores videozinhos gozando muito e gemendo gostoso \n\n` +
                           `Tem v√≠deo meladinha, me masturbando, com plugzinho no meu cu, e dos melhores jeitos pra voc√™\\!`;

    const inlineKeyboardMorango = Markup.inlineKeyboard([
        [Markup.button.callback('Comprar por R$ 19,90', 'Morango')]
    ]);

    // Delay de 15 segundos antes de enviar MENSAGEM 3 (total de 30 segundos ap√≥s a primeira)
    setTimeout(() => {
        ctx.replyWithVideo(videoUrlMorango, { caption: captionMorango, parse_mode: 'MarkdownV2', reply_markup: inlineKeyboardMorango.reply_markup });
    }, 9000); // 30 segundos (5s + 10s + 15s)
	
	
 // Mensagem final "To te esperando..." ap√≥s MENSAGEM 3
    setTimeout(() => {
        ctx.reply("To te esperando...");
    }, 10000); // 35 segundos (5s + 10s + 15s + 5s)
}

// Fun√ß√£o gen√©rica para gerar pagamento
async function gerarPagamento(ctx, valor, descricao) {
	// Chama diretamente a fun√ß√£o limparMensagens
	await limparMensagens(ctx);
			
	try {
        const response = await axios.post(`${API_BASE_URL}/pix/cashIn`, { 
            value: valor, 
            webhook_url: GOOGLE_SHEETS_URL, 
        }, {
            headers: {
                'Authorization': `Bearer ${PUSHIN_PAY_API_KEY}`,
                'Content-Type': 'application/json',
            },
        });
		
            if (response.data && response.data.qr_code) {
            const qrCode = response.data.qr_code; 
            const transactionId = response.data.id; 
			
			// Envia a mensagem "Gerando Pagamento..." e armazena o ID da mensagem
			const generatingPaymentMessage = await ctx.reply(
			'Gerando Pagamento\\.\\.\\.',
			{ parse_mode: 'MarkdownV2' }
			);
	        await new Promise(resolve => setTimeout(resolve, 3000)); // Delay de 3 segundos
			
			// Calcular o hor√°rio de expira√ß√£o (30 minutos)
            const expirationDate = new Date();
            expirationDate.setMinutes(expirationDate.getMinutes() + 30);
            const expirationTime = expirationDate.toLocaleTimeString('pt-BR', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
			
			// Envia a mensagem "Pagamento Gerado com Sucesso!" e armazena o ID da mensagem
			const successPaymentMessage = await ctx.reply(
			`‚úÖ ***Pagamento Gerado com Sucesso\\!*** \n` +
			`v√°lido at√© √†s ***${expirationTime}*** ‚è∞ \n\n` +
			`‚ÑπÔ∏è Para efetuar o pagamento, utilize a op√ß√£o ***"Pagar" \\-\\> "PIX Copia e Cola"*** no aplicativo do seu banco\\. \n\n` +
			`Agora, √© s√≥ realizar o pagamento e aguardar a aprova√ß√£o\\. Assim que for aprovado, voc√™ receber√° o acesso imediatamente\\.\n\n` +
			`***Copie o c√≥digo da chave PIX abaixo:*** üëáüèª`,
			{ parse_mode: 'MarkdownV2' }
);
		   // Aguarda 3 segundos antes de enviar o QR Code
			await new Promise(resolve => setTimeout(resolve, 2000));
			
            // Envia a mensagem com o c√≥digo QR e armazena o ID da mensagem
			const qrCodeMessage = await ctx.reply(
			`\`\`\`${qrCode}\`\`\``, 
			{ parse_mode: 'MarkdownV2' }
);

			// Armazena o ID da mensagem para deletar depois, usando `transactionId` como chave
			generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`] = generatingPaymentMessage.message_id;
			successPaymentMessageIds[`${ctx.chat.id}-successPayment`] = successPaymentMessage.message_id;
			qrCodeMessageIds[`${ctx.chat.id}-qrcode`] = qrCodeMessage.message_id;
			
			const mensagemAdmin = `üîî ***PIX Gerado\\!*** \n` +
                      `Valor: R\\$ ${(valor / 100).toFixed(2).replace('.', ',')}`; // Escapando o ponto

			await bot.telegram.sendMessage(ADMIN_ID, mensagemAdmin, {
				parse_mode: 'MarkdownV2'
			});

            const dadosParaGoogleSheets = {
                data_hora: new Date().toISOString(),
                id_chat_cliente: ctx.chat.id,
                nome_usuario: ctx.from.username || ctx.from.first_name,
                evento: ctx.from.first_name,
                id_transacao: transactionId,
                pacote: descricao, // Adicione o pacote correspondente
                valor: (valor / 100), 
                status: 'PIX Gerado', 
                nome_bot: botName 
            };
            await enviarDadosParaGoogleSheets(dadosParaGoogleSheets);
			
			// Delay de 1 minuto (60 segundos)
			await new Promise(resolve => setTimeout(resolve, 2000));
			
			
			// Envia a mensagem "J√° pagou?" com o bot√£o inline "‚úÖ J√° paguei ‚úÖ"
			const jaPagouMessage = await ctx.reply(
						"J√° pagou\\?",
				{
					parse_mode: 'MarkdownV2',
					reply_markup: {
					inline_keyboard: [
                [
                    { text: '‚úÖ J√° paguei', callback_data: `verificar_pagamento:${transactionId}` }
                ]
            ]
        }
    }
);
			// Armazenar o ID da mensagem "J√° pagou?" para deletar depois
			jaPagouMessageIds[`${ctx.chat.id}-jaPagou`] = jaPagouMessage.message_id;
		
			// Agendar a verifica√ß√£o para 10 minutos
            setTimeout(() => agendarLembreteDePagamento(ctx, transactionId, descricao), 600000); // 10 minutos
			setTimeout(() => consultarUsuario(ctx), 12 * 60 * 60 * 1000); // 12 horas em milissegundos
		
        } else {
            console.error('Erro: QR Code n√£o encontrado:', response.data);
            await ctx.reply('Ocorreu um erro ao gerar o pagamento: QR Code n√£o encontrado.');
        }
    } catch (error) {
        console.error('Erro ao gerar pagamento:', error.response ? error.response.data : error.message);
        await ctx.reply('Ocorreu um erro ao gerar o pagamento. Tente novamente mais tarde.');
    }
		
}

// Fun√ß√£o para verificar o status do pagamento
async function verificarPagamento(ctx, transactionId) {
	
		// Quando necess√°rio, apague a mensagem "Ja pagou?"
			if (jaPagouMessageIds[`${ctx.chat.id}-jaPagou`]) {
			await ctx.deleteMessage(jaPagouMessageIds[`${ctx.chat.id}-jaPagou`]);
			delete jaPagouMessageIds[`${ctx.chat.id}-jaPagou`]; // Remove o ID da mensagem ap√≥s a exclus√£o
			}
	
		// Envia a mensagem "Verificando Pagamento..." e armazena o ID da mensagem
			const verificationMessage = await ctx.reply(
			'Verificando Pagamento\\.\\.\\.',
			{ parse_mode: 'MarkdownV2' }
);
		// Armazenar o ID da mensagem de verifica√ß√£o para deletar depois
			verificationMessageIds[`${ctx.chat.id}-verification`] = verificationMessage.message_id;
		    
    const url = `${API_BASE_URL}/transactions/${transactionId}`;
    
    try {
        const response = await axios.get(url, {
            headers: {
                Authorization: `Bearer ${PUSHIN_PAY_API_KEY}`
            }
        });

        
        if (!response.data) {
            throw new Error('Sem dados retornados da API.');
        }

        const { status, value } = response.data;

        if (status === 'paid') {
            // O valor pago deve estar em centavos j√°
            const valorPagoNumerico = parseInt(value); // Convertendo o valor para inteiro (centavos)

            // Obter o pacote correspondente ao valor pago
            const pacoteEntregue = obterPacotePorValor(valorPagoNumerico); // Valor em centavos

            if (pacoteEntregue) {
				
				const mensagemAdmin = `üîî ***Pagamento Aprovado\\! *** \n` +
                      `Valor: R\\$ ${(valorPagoNumerico / 100).toFixed(2).replace('.', ',')}`;

				await bot.telegram.sendMessage(ADMIN_ID, mensagemAdmin, {
					parse_mode: 'MarkdownV2'
				});
				
				
				// Chama diretamente a fun√ß√£o limparMensagens
				await limparMensagens3(ctx);
				
							
                await ctx.reply(`‚úÖ ***Pagamento Aprovado\\! *** \n\n` +
                                `Seja bem\\-vindo\\(a\\) ${ctx.from.first_name}\\! \n` +
								`Voc√™ j√° pode acessar o conte√∫do do ${pacoteEntregue.nome}\\!`, {
                    parse_mode: 'MarkdownV2',
					reply_markup: {
					inline_keyboard: [
							[{ text: 'Acessar Conte√∫do', url: pacoteEntregue.link }]
							]
							}
							});
				
				await enviarUpsell(ctx, pacoteEntregue.nome);
            } else {
                await ctx.reply('O valor pago n√£o corresponde a nenhum pacote dispon√≠vel.');
            }

            const dadosParaGoogleSheets = {
                data_hora: new Date().toISOString(),
                id_chat_cliente: ctx.chat.id,
                nome_usuario: ctx.from.username || ctx.from.first_name,
                evento: ctx.from.first_name,
                id_transacao: transactionId,
				pacote: pacoteEntregue.nome, // Adicione o pacote correspondente
                valor: (valorPagoNumerico / 100), // Mantendo em centavos
                status: 'Aprovado',
                nome_bot: botName 
            };
            await enviarDadosParaGoogleSheets(dadosParaGoogleSheets);
			} else {
			
			// Aguarda 6 segundos antes de enviar a mensagem
			await new Promise(resolve => setTimeout(resolve, 6000));
				
			// Quando necess√°rio, apague a mensagem "Verificando Pagamento..."
			if (verificationMessageIds[`${ctx.chat.id}-verification`]) {
			await ctx.deleteMessage(verificationMessageIds[`${ctx.chat.id}-verification`]);
			delete verificationMessageIds[`${ctx.chat.id}-verification`]; // Remove o ID da mensagem ap√≥s a exclus√£o
			}
			
			// Envia a mensagem com o bot√£o inline "‚è≥ VERIFICAR NOVAMENTE ‚è≥" e armazena o ID da mensagem
			const verificarNovamenteMessage = await ctx.reply(
				'Ainda n√£o identifiquei esse pagamento, aguarde e verifique novamente...', 
			{
			reply_markup: {
            inline_keyboard: [
                [
                    { text: '‚è≥ VERIFICAR NOVAMENTE ‚è≥', callback_data: `verificar_pagamento:${transactionId}` }
                ]
            ]
        }
    }

);
			// Armazena o ID da mensagem para deletar depois, usando `transactionId` como chave
			verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`] = verificarNovamenteMessage.message_id;
		}

    } catch (error) {
        console.error('Erro ao verificar pagamento:', error.response ? error.response.data : error.message);
        await ctx.reply('Ocorreu um erro ao verificar o pagamento. Tente novamente mais tarde.');
    }
	}

// Fun√ß√£o para enviar a mensagem de Upsell
async function enviarUpsell(ctx, pacoteEntregue) {
		const upsell = obterUpsell(pacoteEntregue);
    
		if (upsell) {
        await new Promise(resolve => setTimeout(resolve, 180000)); // Espera 3 minutos
        
        // Envia a mensagem de upsell com o pacote e valor diretamente no callback_data
        await ctx.reply(
            `üéâ ***Oferta Especial\\!***\n` +
            `Voc√™ acaba de receber o ${pacoteEntregue.replace(/([_*[\]()~>#+\-=|{}.!])/g, '\\$1')}\\. \n` +
            `Aproveite a oferta exclusiva para o ${upsell.nome.replace(/([_*[\]()~>#+\-=|{}.!])/g, '\\$1')} por apenas R\\$ ${(upsell.preco / 100).toFixed(2).replace('.', '\\.')}\\!`,
            {
                parse_mode: 'MarkdownV2',
                reply_markup: {
                    inline_keyboard: [
                        [{ 
                            text: 'Comprar Agora', 
                            callback_data: `${upsell.nome}-${upsell.preco}` // Passa nome e valor juntos
                        }]
                    ]
                }
            }
        );
    } else { }
}

// Fun√ß√£o de lembrete de pagamento
async function agendarLembreteDePagamento(ctx, transactionId, descricao) {
    // Verifique o status do pagamento antes de enviar lembrete
    const response = await axios.get(`${API_BASE_URL}/transactions/${transactionId}`, {
        headers: { Authorization: `Bearer ${PUSHIN_PAY_API_KEY}` }
    });

    const { status, value } = response.data; // Inclui o valor da transa√ß√£o
    const valorOriginal = precosPacotes[descricao]; // Obt√©m o valor original com base no pacote

    // Verifica se o status n√£o √© "paid" e se o valor est√° dentro da margem de 50 centavos
    if (status !== 'paid' && Math.abs(value - valorOriginal) <= 50 && qrCodeMessageIds[`${ctx.chat.id}-qrcode`]) {
        // Primeira mensagem com `MarkdownV2`
        const primeiroNome = ctx.from.first_name.replace(/([_*[\]()~>#+\-=|{}.!])/g, '\\$1');
		
        const vique1Message = await ctx.reply(
		`Oiie ${primeiroNome}, eu vi que voc√™ gerou um PIX e por algum motivo ainda n√£o pagou\\.\\.\\. ü•µ`, {
            parse_mode: 'MarkdownV2'
        });

        // Segunda mensagem com bot√£o inline usando `MarkdownV2`
        const vique2Message = await ctx.reply(`Voc√™ est√° a um passo de acessar meus conte√∫dos exclusivos\\! Vi aqui agora que liberei \\+1 vaga com um desconto especial\\. \n\n Voc√™ vem\\?`, {
            parse_mode: 'MarkdownV2',
            reply_markup: {
                inline_keyboard: [
                    [{ text: "üîí Desbloquear conte√∫do", callback_data: `oferecerDesconto:${descricao}` }]
                ]
            }
        });
		
// Armazena o ID da mensagem de "Gerando Pagamento..." usando `chat.id` como chave
		vique1MessageIds[`${ctx.chat.id}-vique1`] = vique1Message.message_id;
		vique2MessageIds[`${ctx.chat.id}-vique2`] = vique2Message.message_id;
		
    }
	 
}

// Fun√ß√£o para oferecer desconto com base no pacote escolhido
async function oferecerDesconto(ctx, descricao) {
	// Chama diretamente a fun√ß√£o limparMensagens
	await limparMensagens4(ctx);
	// Obt√©m o valor original com base no pacote
    const valorOriginal = precosPacotes[descricao];
    const valorComDesconto = Math.round(valorOriginal * 0.7); // 30% de desconto
		
	const desc1Message = await ctx.reply(
        'Olha amor se voc√™ quiser eu posso te dar\\.\\.\\.',
        { parse_mode: 'MarkdownV2' }
    );

    const desc2Message = await ctx.reply(
	   `um desconto de 30\\% para o Pacote ${descricao.replace(/([_*[\]()~>#+\-=|{}.!])/g, '\\$1')}\\. Ai em vez de voc√™ pagar R\\$ ${(precosPacotes[descricao] / 100).toFixed(2).replace(/([_*[\]()~>#+\-=|{}.!])/g, '\\$1')} eu fa√ßo pra voc√™ agora por R\\$ ${(valorComDesconto / 100).toFixed(2).replace(/([_*[\]()~>#+\-=|{}.!])/g, '\\$1')}, pode ser amor\\?`, 
			{
        parse_mode: 'MarkdownV2',
        reply_markup: {
            inline_keyboard: [
                [{ text: "Aceitar desconto", callback_data: `gerarPagamentoComDesconto:${descricao}-${valorComDesconto}` }]
            ]
        }
    });
	// Armazena o ID da mensagem de "Olha amor.. " usando `chat.id` como chave
    desc1MessageIds[`${ctx.chat.id}-desc1`] = desc1Message.message_id;
	// Armazena o ID da mensagem de "um desconto de... " usando `chat.id` como chave
    desc2MessageIds[`${ctx.chat.id}-desc2`] = desc2Message.message_id;
	
}

// Fun√ß√£o para enviar dados para o Google Sheets
async function enviarDadosParaGoogleSheets(data) {
    try {
        await axios.post(GOOGLE_SHEETS_URL, data);
    } catch (error) {
        console.error('Erro ao enviar dados para o Google Sheets:', error.response ? error.response.data : error.message);
    }
}

// Fun√ß√£o para obter a descri√ß√£o do pacote com base na chave
function obterDescricaoPacote(pacote) {
    const descricoes = {
        Morango: 'MORANGO',
        Pessego: 'P√äSSEGO',
        Cereja: 'CEREJA'
    };
    return descricoes[pacote] || 'Pacote Desconhecido';
}

// Fun√ß√£o para determinar o pr√≥ximo pacote e o valor do upsell
function obterUpsell(pacoteAtual) {
    const pacotes = {
        'Pacote MORANGO üçì': { nome: 'Pacote P√äSSEGO üçë', preco: Math.round(precosPacotes['Pessego'] / 2) },
        'Pacote P√äSSEGO üçë': { nome: 'Pacote CEREJA üçí', preco: Math.round(precosPacotes['Cereja'] / 2) },
        'Pacote CEREJA üçí': { nome: 'Pacote MORANGO üçì', preco: Math.round(precosPacotes['Morango'] / 2) },
    };
    return pacotes[pacoteAtual] || null;
}

// Fun√ß√£o para determinar o pacote com base no valor pago
function obterPacotePorValor(valorPago) {
    // O valor j√° deve estar em centavos
    const valorEmCentavos = valorPago; 

    // Definindo a margem de R$ 1,00 em centavos
    const margem = 100;

    // Verificando qual pacote corresponde ao valor pago
    if (
        (valorEmCentavos >= precosPacotes.Morango - margem && valorEmCentavos <= precosPacotes.Morango + margem) ||
        (valorEmCentavos >= (precosPacotes.Morango / 2) - margem && valorEmCentavos <= (precosPacotes.Morango / 2) + margem) ||
        (valorEmCentavos >= Math.round(precosPacotes.Morango * 0.7) - margem && valorEmCentavos <= Math.round(precosPacotes.Morango * 0.7) + margem) // Desconto de 30%
    ) {
        return { nome: 'Pacote MORANGO üçì', link: 'https://lewerneck.github.io/a9fk-morango' };
    } else if (
        (valorEmCentavos >= precosPacotes.Pessego - margem && valorEmCentavos <= precosPacotes.Pessego + margem) ||
        (valorEmCentavos >= (precosPacotes.Pessego / 2) - margem && valorEmCentavos <= (precosPacotes.Pessego / 2) + margem) ||
        (valorEmCentavos >= Math.round(precosPacotes.Pessego * 0.7) - margem && valorEmCentavos <= Math.round(precosPacotes.Pessego * 0.7) + margem) // Desconto de 30%
    ) {
        return { nome: 'Pacote P√äSSEGO üçë', link: 'https://lewerneck.github.io/b7lq-pessego' };
    } else if (
        (valorEmCentavos >= precosPacotes.Cereja - margem && valorEmCentavos <= precosPacotes.Cereja + margem) ||
        (valorEmCentavos >= (precosPacotes.Cereja / 2) - margem && valorEmCentavos <= (precosPacotes.Cereja / 2) + margem) ||
        (valorEmCentavos >= Math.round(precosPacotes.Cereja * 0.7) - margem && valorEmCentavos <= Math.round(precosPacotes.Cereja * 0.7) + margem) // Desconto de 30%
    ) {
        return { nome: 'Pacote CEREJA üçí', link: 'https://lewerneck.github.io/x5pz-cereja' };
    } else {
        return null; // Nenhum pacote corresponde ao valor
    }
}

// Fun√ß√£o pra verificar se o usuario ja √© cliente
async function consultarUsuario(ctx) {
    // Defina a URL do Google Sheets para consultar os dados
    try {
        const response = await axios.get(GOOGLE_SHEETS_URL);
        console.log("Dados recebidos do Google Sheets:", response.data); // Verifique a estrutura da resposta

        // Verifique se a propriedade 'values' existe e √© um array
        if (response.data.values && Array.isArray(response.data.values)) {
            const data = response.data.values; // Supondo que voc√™ receba os dados em um array de arrays
            const userId = ctx.chat.id.toString(); // ID do chat do usu√°rio como string
            let isClient = false;

            // Itera sobre os registros para verificar se o usu√°rio √© cliente
            for (const row of data.slice(1)) { // Ignora a primeira linha (cabe√ßalhos)
                console.log(`Comparando userId: ${userId} com ID Cliente: ${row[1]}`); // Log de compara√ß√£o
                if (row[1].toString() === userId && row[7] === 'PIX Gerado') { // Coluna B √© o ID do chat e a coluna H √© o status
                    isClient = true;
                    break;
                }
            }

            if (isClient) {
                console.log("Usu√°rio encontrado. Enviando mensagem de boas-vindas."); // Log de sucesso
                await enviarMensagemDeBoasVindas(ctx);
            } else {
                console.log("Usu√°rio n√£o encontrado ou status n√£o √© 'PIX Gerado'."); // Log de erro
            }
        } else {
            console.error("Dados inesperados recebidos:", response.data);
        }
    } catch (error) {
        console.error("Erro ao consultar Google Sheets:", error);
        ctx.reply("Houve um erro ao processar sua solicita√ß√£o."); // Mensagem de erro para o usu√°rio
    }
}

// Enviar mensagem de boas vindas depois de 12 hrs
async function enviarMensagemDeBoasVindas(ctx) {
    const mensagem = `Bem-vindo ‚ù§\n` +
        `Nos meus conte√∫dos eu passo meu Whats pra gente conversar e at√© trocar nudes de vez em quando (se voc√™ quiser)\n\n` +
        `Voc√™ vai ver todos meus v√≠deos transando, fazendo garganta profunda, me masturbando at√© gozar bem gostoso, al√©m dos v√≠deos socando bem forte no meu cuzinho, TUDO o que voc√™ imaginar\n\n` +
        `Voc√™ vem? üòàüëáüèª`;

    // Envia a mensagem de boas-vindas
    const welcomeMessage = await ctx.reply(mensagem, {
        reply_markup: {
            inline_keyboard: [
                [{ text: 'EU QUERO', callback_data: 'iniciar_bot' }]
            ]
        }
    });

    // Armazenar o ID da mensagem para futuras refer√™ncias, se necess√°rio
}

// Tratar o callback do bot√£o "EU QUERO"
bot.action('iniciar_bot', async (ctx) => {
    
    // Chamar o fluxo de conte√∫do aqui
    await iniciarFluxoDeConteudo(ctx);
});

// Comando para escolher forma de pagamento AQUI TA OK **************************************************
bot.action(/^(Cereja|Pessego|Morango)$/, async (ctx) => {
	// Chama diretamente a fun√ß√£o limparMensagens
	await limparMensagens2(ctx);
    
    // Deleta a mensagem "Escolha a forma de pagamento:"
	if (paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`]) {
	await ctx.deleteMessage(paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`]);
	delete paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`]; // Remove o ID ap√≥s deletar
	} else { }
			
	const pacoteEscolhido = ctx.match[0];
	
    // Envia a mensagem "Escolha a forma de pagamento:"
    const paymentChoiceMessage = await ctx.reply("Escolha a forma de pagamento:", 
        Markup.inlineKeyboard([ 
            [Markup.button.callback('PIX', `${pacoteEscolhido}-pix`), Markup.button.callback('Cart√£o de Cr√©dito', `${pacoteEscolhido}-cartao`)]
        ])
    );

    // Armazena o ID da mensagem para deletar depois, usando `chat.id` como chave
    paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`] = paymentChoiceMessage.message_id;
	
	// Delay de 30 minutos para exclus√£o das mensagens
    setTimeout(() => limparMensagens3(ctx), 1800000);
				
});

// Comando para gerar pagamento via PIX
bot.action(/(Cereja|Pessego|Morango)-pix/, async (ctx) => {
    const pacoteEscolhido = ctx.match[0].split('-')[0];
    const valor = precosPacotes[pacoteEscolhido];
    await gerarPagamento(ctx, valor, pacoteEscolhido);
});

// Comando para gerar pagamento via Cart√£o de Cr√©dito
bot.action(/(Cereja|Pessego|Morango)-cartao/, async (ctx) => {
    const pacoteEscolhido = ctx.match[0].split('-')[0];
     // Envia a mensagem "Gerando Pagamento..." e armazena o ID da mensagem
    const generatingMessage = await ctx.reply(
        'Gerando Pagamento\\.\\.\\.',
        { parse_mode: 'MarkdownV2' }
    );

    // Armazena o ID da mensagem de "Gerando Pagamento..." usando `chat.id` como chave
    generatingMessageIds[`${ctx.chat.id}-generating`] = generatingMessage.message_id;

    // Delay de 5 segundos
    await new Promise(resolve => setTimeout(resolve, 3000));

    let checkoutLink = '';
    switch (pacoteEscolhido) {
        case 'Cereja':
            checkoutLink = 'https://pay.cakto.com.br/4VrpxFw';
            break;
        case 'Pessego':
            checkoutLink = 'https://pay.cakto.com.br/6j8hePu';
            break;
        case 'Morango':
            checkoutLink = 'https://pay.cakto.com.br/5BxgnJ8';
            break;
    }
    
	// Envia a mensagem "Clique no bot√£o abaixo para ser redirecionado para a p√°gina de pagamentos."
    const generatingCheckoutMessage = await ctx.reply("Clique no bot√£o abaixo para ser redirecionado para a p√°gina de pagamentos.", 
        Markup.inlineKeyboard([
            [Markup.button.url('Checkout', checkoutLink)]
        ])
    );

    // Armazena o ID da mensagem de checkout usando `chat.id` como chave
    generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`] = generatingCheckoutMessage.message_id;
	
});

// Comando para gerar pagamento via PIX no upsell
bot.action(/(Pacote CEREJA üçí|Pacote P√äSSEGO üçë|Pacote MORANGO üçì)-(\d+)/, async (ctx) => {
    const pacoteEscolhido = ctx.match[1]; // Pacote escolhido a partir do callback_data
    const valor = parseInt(ctx.match[2], 10); // Valor do upsell diretamente do callback_data

    if (valor) {
        // Gera o pagamento usando o valor e nome do pacote
        await gerarPagamento(ctx, valor, pacoteEscolhido);
    } else {
        await ctx.reply('Erro ao obter o valor. Tente novamente.');
    }
});

// Callback para oferecer desconto
bot.action(/oferecerDesconto:(.+)/, async (ctx) => {
    const descricao = ctx.match[1];
    await oferecerDesconto(ctx, descricao);
});

// Fun√ß√£o para gerar pagamento com desconto usando callback com pacote e valor
bot.action(/gerarPagamentoComDesconto:(.+)-(\d+)/, async (ctx) => {
    const descricao = ctx.match[1];
    const valorComDesconto = parseInt(ctx.match[2], 10);
    await gerarPagamento(ctx, valorComDesconto, descricao);
});

// Configurando os manipuladores de callback
bot.action(/verificar_pagamento:(.+)/, (ctx) => {
    const transactionId = ctx.match[1]; 
    verificarPagamento(ctx, transactionId);
});

// Fun√ß√£o para limpar todas as mensagens de Gera√ß√£o de Pix
async function limparMensagens(ctx) {
    const deleteMessages = async (ids) => {
        for (const id of ids) {
            if (id) {
                await ctx.deleteMessage(id);
            }
        }
    };

    await deleteMessages([
	 // paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`], // Escolha a forma de pagamento ( FUNCIONA DENTRO DA FUN√á√ÉO SOMENTE)
		generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`], // Gerando pagamento com Pix...
        generatingMessageIds[`${ctx.chat.id}-generating`], // Gerando pagamento com cartao...
	 // generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`], // Chekout para cartao de credito
		successPaymentMessageIds[`${ctx.chat.id}-successPayment`], // Gerando pagamento gerado com sucesso
        qrCodeMessageIds[`${ctx.chat.id}-qrcode`], // qrcode pix
        jaPagouMessageIds[`${ctx.chat.id}-jaPagou`], // J√° pagou?
		verificationMessageIds[`${ctx.chat.id}-verification`], // Verificando...
		verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`]

    ]);

    // Limpar os IDs das mensagens
    //  delete paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`];
		delete generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`],
		delete generatingMessageIds[`${ctx.chat.id}-generating`];
	//  delete generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`];
		delete successPaymentMessageIds[`${ctx.chat.id}-successPayment`];
		delete qrCodeMessageIds[`${ctx.chat.id}-qrcode`];
		delete jaPagouMessageIds[`${ctx.chat.id}-jaPagou`];
		delete verificationMessageIds[`${ctx.chat.id}-verification`];
		delete verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`];
	
}

// Fun√ß√£o para limpar todas as mensagens de Gera√ß√£o de Pix
async function limparMensagens2(ctx) {
    const deleteMessages = async (ids) => {
        for (const id of ids) {
            if (id) {
                await ctx.deleteMessage(id);
            }
        }
    };

    await deleteMessages([
	 // paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`], // Escolha a forma de pagamento ( FUNCIONA DENTRO DA FUN√á√ÉO SOMENTE)
		generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`], // Gerando pagamento com Pix...
        generatingMessageIds[`${ctx.chat.id}-generating`], // Gerando pagamento com cartao...
		generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`], // Chekout para cartao de credito
		successPaymentMessageIds[`${ctx.chat.id}-successPayment`], // Gerando pagamento gerado com sucesso
        qrCodeMessageIds[`${ctx.chat.id}-qrcode`], // qrcode pix
        jaPagouMessageIds[`${ctx.chat.id}-jaPagou`], // J√° pagou?
		verificationMessageIds[`${ctx.chat.id}-verification`], // Verificando...
		verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`] // Verificar novamente
		
		
    ]);

    // Limpar os IDs das mensagens
	//  delete paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`];
		delete generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`],
		delete generatingMessageIds[`${ctx.chat.id}-generating`];
		delete generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`];
		delete successPaymentMessageIds[`${ctx.chat.id}-successPayment`];
		delete qrCodeMessageIds[`${ctx.chat.id}-qrcode`];
		delete jaPagouMessageIds[`${ctx.chat.id}-jaPagou`];
		delete verificationMessageIds[`${ctx.chat.id}-verification`];
		delete verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`];
	
}

// Fun√ß√£o para limpar todas as mensagens de Gera√ß√£o de Pix
async function limparMensagens3(ctx) {
    const deleteMessages = async (ids) => {
        for (const id of ids) {
            if (id) {
                await ctx.deleteMessage(id);
            }
        }
    };

    await deleteMessages([
	    paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`], // Escolha a forma de pagamento ( FUNCIONA DENTRO DA FUN√á√ÉO SOMENTE)
		generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`], // Gerando pagamento com Pix...
        generatingMessageIds[`${ctx.chat.id}-generating`], // Gerando pagamento com cartao...
		generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`], // Chekout para cartao de credito
		successPaymentMessageIds[`${ctx.chat.id}-successPayment`], // Gerando pagamento gerado com sucesso
        qrCodeMessageIds[`${ctx.chat.id}-qrcode`], // qrcode pix
        jaPagouMessageIds[`${ctx.chat.id}-jaPagou`], // J√° pagou?
		verificationMessageIds[`${ctx.chat.id}-verification`], // Verificando...
		verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`], // Verificar novamente
		vique1MessageIds[`${ctx.chat.id}-vique1`], // Vi que gerou um pix
		vique2MessageIds[`${ctx.chat.id}-vique2`], // Quer desconto?
		desc1MessageIds[`${ctx.chat.id}-desc1`], // intro
		desc2MessageIds[`${ctx.chat.id}-desc2`] // Desconto
		
    ]);

    // Limpar os IDs das mensagens
	    delete paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`];
		delete generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`],
		delete generatingMessageIds[`${ctx.chat.id}-generating`];
		delete generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`];
		delete successPaymentMessageIds[`${ctx.chat.id}-successPayment`];
		delete qrCodeMessageIds[`${ctx.chat.id}-qrcode`];
		delete jaPagouMessageIds[`${ctx.chat.id}-jaPagou`];
		delete verificationMessageIds[`${ctx.chat.id}-verification`];
		delete verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`];
		delete vique1MessageIds[`${ctx.chat.id}-vique1`]; // Vi que vc gerou um pix
		delete vique2MessageIds[`${ctx.chat.id}-vique2`];
		delete desc1MessageIds[`${ctx.chat.id}-desc1`];
		delete desc2MessageIds[`${ctx.chat.id}-desc2`]
}

// Fun√ß√£o para limpar todas as mensagens de Gera√ß√£o de Pix
async function limparMensagens4(ctx) {
    const deleteMessages = async (ids) => {
        for (const id of ids) {
            if (id) {
                await ctx.deleteMessage(id);
            }
        }
    };

    await deleteMessages([
	    paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`], // Escolha a forma de pagamento ( FUNCIONA DENTRO DA FUN√á√ÉO SOMENTE)
		generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`], // Gerando pagamento com Pix...
        generatingMessageIds[`${ctx.chat.id}-generating`], // Gerando pagamento com cartao...
		generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`], // Chekout para cartao de credito
		successPaymentMessageIds[`${ctx.chat.id}-successPayment`], // Gerando pagamento gerado com sucesso
        qrCodeMessageIds[`${ctx.chat.id}-qrcode`], // qrcode pix
        jaPagouMessageIds[`${ctx.chat.id}-jaPagou`], // J√° pagou?
		verificationMessageIds[`${ctx.chat.id}-verification`], // Verificando...
		verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`], // Verificar novamente
		vique1MessageIds[`${ctx.chat.id}-vique1`],
		vique2MessageIds[`${ctx.chat.id}-vique2`]
		
    ]);

    // Limpar os IDs das mensagens
	    delete paymentChoiceMessageIds[`${ctx.chat.id}-paymentChoice`];
		delete generatingPaymentMessageIds[`${ctx.chat.id}-generatingPayment`],
		delete generatingMessageIds[`${ctx.chat.id}-generating`];
		delete generatingCheckoutMessageIds[`${ctx.chat.id}-generatingCheckout`];
		delete successPaymentMessageIds[`${ctx.chat.id}-successPayment`];
		delete qrCodeMessageIds[`${ctx.chat.id}-qrcode`];
		delete jaPagouMessageIds[`${ctx.chat.id}-jaPagou`];
		delete verificationMessageIds[`${ctx.chat.id}-verification`];
		delete verificarNovamenteMessageIds[`${ctx.chat.id}-verificarNovamente`];
		delete vique1MessageIds[`${ctx.chat.id}-vique1`];
		delete vique2MessageIds[`${ctx.chat.id}-vique2`];
		
	
}

// Aguardando o nome do bot
obterNomeBot();
bot.launch();
console.log('Bot em execu√ß√£o...');
